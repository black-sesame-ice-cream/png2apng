<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNG to APNG 変換</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>


    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* ドラッグオーバー時のスタイル */
        .drag-over {
            border-color: #3b82f6; /* blue-500 */
            background-color: #262f4d; /* slate-800の暗い版 */
        }
        
        /* --- ドラッグ＆ドロップ並び替え用スタイル --- */
        /* ドラッグ中のアイテム本体 (ゴーストではない) */
        .dragging {
            opacity: 0.5;
            background: #4a5568; /* slate-600 */
            cursor: grabbing;
        }
        /* li 自体にカーソルスタイルを追加 */
        #media-list li[draggable="true"],
        #frames-list li[draggable="true"] {
            cursor: grab;
        }
        
        /* 挿入位置インジケータ (上) */
        .drag-over-indicator-before {
            position: relative;
        }
        .drag-over-indicator-before::before {
            content: '';
            position: absolute;
            top: -2px; /* 線の太さ分上に */
            left: 0;
            right: 0;
            height: 2px;
            background-color: #3b82f6; /* blue-500 */
            z-index: 10;
        }
        
        /* 挿入位置インジケータ (下) */
        .drag-over-indicator-after {
            position: relative;
        }
        .drag-over-indicator-after::after {
            content: '';
            position: absolute;
            bottom: -2px; /* 線の太さ分下に */
            left: 0;
            right: 0;
            height: 2px;
            background-color: #3b82f6; /* blue-500 */
            z-index: 10;
        }

        /* フレームリストのプレビュー画像 */
        .frame-preview {
            width: 4rem; /* w-16 */
            height: 4rem; /* h-16 */
            object-fit: cover;
        }

        /* ▼▼▼ モーダル用スタイル ▼▼▼ */
        #preview-modal {
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #preview-modal.hidden {
            opacity: 0;
            visibility: hidden;
        }
        #preview-modal:not(.hidden) {
            opacity: 1;
            visibility: visible;
        }
        #preview-image-container {
            width: 600px; /* 固定幅 */
            height: 600px; /* 固定高 */
            max-width: 90vw; /* 画面幅が狭い場合 */
            max-height: 80vh; /* 画面高が低い場合 */
        }
        #preview-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .github-icon-link {position: fixed; top: 4px; left: 4px; z-index: 999;}
        .github-icon-link img {width: 32px; height: 32px;}
        .github-icon-link:hover img {transform: scale(1.1);}

    </style>
</head>
<body class="bg-slate-900 text-gray-300 min-h-screen p-4 sm:p-8">

    <!-- ▼▼▼ ローディングオーバーレイ ▼▼▼ -->
    <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center hidden">
        <div class="flex flex-col items-center">
            <!-- スピナー (Tailwind CSS) -->
            <svg class="animate-spin h-10 w-10 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span class="text-white text-lg font-semibold">APNGに変換中...</span>
            <span id="loading-progress" class="text-white text-sm mt-2"></span>
        </div>
    </div>
    <!-- ▲▲▲ ローディングオーバーレイ ▲▲▲ -->

    <!-- ▼▼▼ プレビューモーダル ▼▼▼ -->
    <div id="preview-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-40 flex items-center justify-center p-4">
        <!-- モーダル背景 (クリックで閉じる) -->
        <div class="absolute inset-0" id="modal-bg-close"></div>
        
        <div class="bg-slate-800 shadow-xl z-50 flex flex-col relative" id="preview-image-container">
            <!-- ヘッダーと閉じるボタン -->
            <div class="flex justify-between items-center p-4 border-b border-slate-700">
                <h3 class="text-xl font-semibold text-white">プレビュー</h3>
                <button id="close-modal-btn" class="text-slate-400 hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <!-- プレビュー画像 -->
            <div class="p-4 flex-grow flex items-center justify-center overflow-auto">
                <img id="preview-image" src="" alt="APNG Preview" class="border border-slate-700">
            </div>
        </div>
    </div>
    <!-- ▲▲▲ プレビューモーダル ▲▲▲ -->


    <div class="max-w-7xl mx-auto">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-white mb-2">PNG to APNG 変換ツール</h1>
        </header>

        <!-- カラムコンテナ -->
        <div class="flex flex-col md:flex-row md:space-x-8">

            <div class="md:w-2/5 flex flex-col">

                <div id="drop-zone" class="border-4 border-dashed border-slate-700 rounded-lg p-8 text-center cursor-pointer hover:border-blue-600 hover:bg-slate-800 h-96 flex flex-col">
                    <input type="file" id="file-input" multiple accept="image/png" class="hidden">
                    <label for="file-input" class="cursor-pointer flex flex-col items-center justify-center h-full w-full">
                        <svg class="mx-auto h-12 w-12 text-slate-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
                        </svg>
                        <p class="mt-2 text-lg font-semibold text-white">PNGファイルをドラッグ＆ドロップ</p>
                        <p class="text-sm text-slate-400">またはクリックしてファイルを選択</p>
                        <p class="text-xs text-slate-500 mt-2">対応: PNG</p>
                    </label>
                </div>
                
            </div>
            
            <section id="media-pool-section" class="mt-8 md:mt-0 md:w-3/5 flex flex-col">

                <!-- ファイルリストコンテナ (高さを h-96 で固定) -->
                <div class="bg-slate-800 rounded-lg p-4 flex flex-col h-96">
                    <div class="flex justify-between items-center mb-4 flex-shrink-0">
                        <h2 class="text-2xl font-semibold text-white">ファイルリスト</h2>
                        
                        <div class="flex items-center space-x-4">
                            <!-- ソートボタン -->
                            <div class="flex items-center space-x-2">
                                <button id="sort-asc-btn" class="text-slate-300 hover:text-white disabled:opacity-50" title="名前順 (昇順)" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                      <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                                    </svg>
                                </button>
                                <button id="sort-desc-btn" class="text-slate-300 hover:text-white disabled:opacity-50" title="名前順 (降順)" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                      <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
                                    </svg>
                                </button>
                            </div>
                            <!-- クリアボタン -->
                            <button id="clear-pool-btn" class="bg-red-600 text-white text-xs font-bold px-3 py-1 rounded hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed" title="すべてクリア" disabled>
                                すべてクリア
                            </button>
                        </div>

                    </div>
                    
                    <ul id="media-list" class="space-y-1 overflow-y-auto flex-grow h-0">
                        <li id="empty-pool-message" class="text-slate-400 text-center py-16">ファイルがありません</li>
                    </ul>
                    
                    <!-- フレームに送るボタン -->
                    <div class="mt-4 flex-shrink-0">
                        <button id="send-to-frames-btn" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            ▼ フレームに送る
                        </button>
                    </div>
                </div>

            </section>
        
        </div> <!-- カラムコンテナ終了 -->
        
        <!-- メニューバーと変換ボタンのセクション -->
        <section class="mt-8">
            <!-- メニューバー (変換オプション) -->
            <div class="bg-slate-800 rounded-lg p-4 mb-4">
                <h3 class="text-xl font-semibold text-white mb-3">変換オプション</h3>
                <div class="flex flex-wrap gap-4 items-end">
                    <div class="flex-1 min-w-[200px]">
                        <label for="delay-input" class="block text-sm font-medium text-slate-300 mb-1">保持時間 (ms)</label>
                        <div class="flex space-x-2">
                            <input type="number" id="delay-input" value="50" min="1" step="1" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="apply-delay-all-btn" class="bg-indigo-600 text-white text-sm font-bold px-4 py-2 rounded-lg hover:bg-indigo-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex-shrink-0" title="全フレームに適用" disabled>
                                適用
                            </button>
                        </div>
                    </div>
                    <div class="flex-1 min-w-[200px]">
                        <label for="loop-input" class="block text-sm font-medium text-slate-300 mb-1">ループ回数 (0=無限, ※無限ループにしかならないバグあり)</label>
                        <input type="number" id="loop-input" value="0" min="0" step="1" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="flex-1 min-w-[200px]">
                        <label for="output-width" class="block text-sm font-medium text-slate-300 mb-1">幅 (px)</label>
                        <input type="number" id="output-width" min="1" step="1" placeholder="自動" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="flex-1 min-w-[200px]">
                        <label for="output-height" class="block text-sm font-medium text-slate-300 mb-1">高さ (px)</label>
                        <input type="number" id="output-height" min="1" step="1" placeholder="自動" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <!-- ▼▼▼ 減色オプションをプルダウンに変更 ▼▼▼ -->
                    <div class="flex-1 min-w-[200px]">
                        <label for="color-depth-select" class="block text-sm font-medium text-slate-300 mb-1">色深度 (減色)</label>
                        <select id="color-depth-select" class="w-full bg-slate-700 text-white border border-slate-600 rounded-md p-2 h-[42px] focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="0">圧縮なし (フルカラー)</option>
                            <option value="8">8ビット (256色)</option>
                            <option value="4">4ビット (16色)</option>
                            <option value="2">2ビット (4色)</option>
                            <option value="1">1ビット (2色)</option>
                        </select>
                    </div>
                    <!-- ▲▲▲ 減色オプションをプルダウンに変更 ▲▲▲ -->
                </div>
            </div>

            <section id="frames-list-section" class="mt-8">
                <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-4">
                    <div>
                        <h3 class="text-2xl font-semibold text-white">フレームシーケンス</h3>
                        <div class="flex items-center flex-wrap space-x-4 text-sm text-slate-400 mt-2">
                            <span>
                                フレーム数: <strong id="seq-frame-count" class="text-slate-300 font-medium">0</strong>
                            </span>
                            <span>
                                合計時間: <strong id="seq-duration" class="text-slate-300 font-medium">0.00</strong> s
                            </span>
                            <span>
                                平均FPS: <strong id="seq-avg-fps" class="text-slate-300 font-medium">0.0</strong>
                            </span>
                        </div>
                    </div>
                    <!-- ▼▼▼ プレビューボタンと変換ボタンのコンテナ ▼▼▼ -->
                    <div class="flex-shrink-0 self-start sm:self-center flex items-center space-x-3">
                        <!-- プレビューボタン -->
                        <button id="preview-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center" disabled>
                            <svg class="animate-spin h-5 w-5 mr-3 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span class="btn-text">プレビュー</span>
                        </button>
                        <!-- 変換ボタン -->
                        <button id="convert-btn-top" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center" disabled>
                            <svg class="animate-spin h-5 w-5 mr-3 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span class="btn-text">APNGを保存</span>
                        </button>
                    </div>
                    <!-- ▲▲▲ プレビューボタンと変換ボタンのコンテナ ▲▲▲ -->
                </div>
                <div id="frames-list-container" class="bg-slate-800 rounded-lg p-1 min-h-[10rem]">
                    <ul id="frames-list" class="space-y-1">
                        <li id="empty-frames-message" class="text-slate-400 text-center py-16">
                            「▼ フレームに送る」ボタンでファイルを追加してください
                        </li>
                    </ul>
                </div>
            </section>

            <!-- 変換ボタン (下) -->
            <div class="mt-8">
                <button id="convert-btn-bottom" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center" disabled>
                    <svg class="animate-spin h-5 w-5 mr-3 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span class="btn-text">APNGを保存</span>
                </button>
            </div>
            
        </section>

        <a href="https://github.com/black-sesame-ice-cream/png2apng" target="_blank" rel="noopener noreferrer" class="github-icon-link" title="View on GitHub">
            <img src="images/github-icon.svg" alt="GitHub" />
        </a>
        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM要素 ---
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            const mediaList = document.getElementById('media-list');
            const clearPoolBtn = document.getElementById('clear-pool-btn');
            const sortAscBtn = document.getElementById('sort-asc-btn');
            const sortDescBtn = document.getElementById('sort-desc-btn');
            const sendToFramesBtn = document.getElementById('send-to-frames-btn');
            
            const delayInput = document.getElementById('delay-input');
            const loopInput = document.getElementById('loop-input');
            const outputWidthInput = document.getElementById('output-width');
            const outputHeightInput = document.getElementById('output-height');
            const applyDelayAllBtn = document.getElementById('apply-delay-all-btn');
            
            // ▼▼▼ quantizeToggle から colorDepthSelect に変更 ▼▼▼
            const colorDepthSelect = document.getElementById('color-depth-select');
            // ▲▲▲ quantizeToggle から colorDepthSelect に変更 ▲▲▲
            
            const framesListContainer = document.getElementById('frames-list-container');
            const framesList = document.getElementById('frames-list');
            
            const emptyPoolMessage = document.getElementById('empty-pool-message');
            const emptyFramesMessage = document.getElementById('empty-frames-message');
            
            if (emptyPoolMessage) emptyPoolMessage.remove();
            if (emptyFramesMessage) emptyFramesMessage.remove();
            
            const convertBtnTop = document.getElementById('convert-btn-top');
            const convertBtnBottom = document.getElementById('convert-btn-bottom');
            
            // ▼▼▼ プレビューモーダル関連のDOM要素 ▼▼▼
            const previewBtn = document.getElementById('preview-btn');
            const previewModal = document.getElementById('preview-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const modalBgClose = document.getElementById('modal-bg-close');
            const previewImage = document.getElementById('preview-image');
            // ▲▲▲ プレビューモーダル関連のDOM要素 ▲▲▲
            
            const seqFrameCountEl = document.getElementById('seq-frame-count');
            const seqDurationEl = document.getElementById('seq-duration');
            const seqAvgFpsEl = document.getElementById('seq-avg-fps');

            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingProgress = document.getElementById('loading-progress');
            
            const mediaPool = []; // { id, name, size, type, dataUrl, originalFile }
            const framesPool = []; // { id, name, dataUrl, originalFile, delay }
            
            let draggingId = null;
            let dragOverId = null;
            let draggingList = null; 

            // ▼▼▼ プレビューキャッシュ用変数 ▼▼▼
            let lastPreviewBlobUrl = null;
            let lastPreviewSettingsHash = null;
            // ▲▲▲ プレビューキャッシュ用変数 ▲▲▲

            const supportedTypes = ['image/png'];

            // --- ▼▼▼ プレビューキャッシュ関連 ▼▼▼ ---
            /**
             * 現在の設定から一意のハッシュ（簡易的なシリアライズ）を生成する
             */
            function getCurrentSettingsHash() {
                // フレームIDと遅延のリスト
                const frameSettings = framesPool.map(f => `${f.id}:${f.delay}`).join(',');
                
                // その他の設定
                const otherSettings = [
                    delayInput.value,
                    loopInput.value,
                    outputWidthInput.value,
                    outputHeightInput.value,
                    colorDepthSelect.value
                ].join('|');
                
                return `${frameSettings}|${otherSettings}`;
            }

            /**
             * プレビューキャッシュを無効化する
             */
            function invalidatePreviewCache() {
                if (lastPreviewBlobUrl) {
                    URL.revokeObjectURL(lastPreviewBlobUrl);
                    lastPreviewBlobUrl = null;
                    // console.log("Preview cache (Blob) revoked."); // デバッグ用
                }
                lastPreviewSettingsHash = null;
                // console.log("Preview cache invalidated."); // デバッグ用
            }
            // --- ▲▲▲ プレビューキャッシュ関連 ▲▲▲ ---


            // --- イベントリスナー ---

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
                e.target.value = null;
            });

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
            });
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
                handleFiles(e.dataTransfer.files);
            });
            
            sortAscBtn.addEventListener('click', () => {
                mediaPool.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
                renderMediaPool();
            });
            sortDescBtn.addEventListener('click', () => {
                mediaPool.sort((a, b) => b.name.localeCompare(a.name, undefined, { numeric: true }));
                renderMediaPool();
            });
            
            clearPoolBtn.addEventListener('click', () => {
                if (mediaPool.length === 0) return;
                mediaPool.length = 0;
                renderMediaPool();
            });

            sendToFramesBtn.addEventListener('click', async () => {
                if (mediaPool.length === 0) return;
                
                const defaultDelay = parseInt(delayInput.value, 10) || 100;
                const wasFramesPoolEmpty = framesPool.length === 0;

                const newFrames = mediaPool.map(item => ({
                    id: crypto.randomUUID(),
                    name: item.name,
                    dataUrl: item.dataUrl,
                    originalFile: item.originalFile, 
                    delay: defaultDelay
                }));
                
                framesPool.push(...newFrames);
                
                mediaPool.length = 0;
                renderMediaPool();
                renderFramesList();
                
                invalidatePreviewCache(); // ★ キャッシュ無効化

                if (wasFramesPoolEmpty && framesPool.length > 0 && !outputWidthInput.value && !outputHeightInput.value) {
                    try {
                        await setDefaultDimensions(framesPool[0]);
                    } catch (err) {
                        console.error("Failed to set default dimensions:", err);
                    }
                }
            });

            applyDelayAllBtn.addEventListener('click', () => {
                if (framesPool.length === 0) return;
                
                const newDelay = parseInt(delayInput.value, 10);
                if (isNaN(newDelay) || newDelay < 1) {
                    console.warn("Invalid delay value for applying all:", newDelay);
                    return;
                }
                
                framesPool.forEach(frame => {
                    frame.delay = newDelay;
                });
                
                renderFramesList();
                invalidatePreviewCache(); // ★ キャッシュ無効化
            });

            // --- 入力値検証リスナー (blurイベント) ---
            delayInput.addEventListener('blur', () => {
                const min = 1;
                let value = parseInt(delayInput.value, 10);
                if (isNaN(value) || value < min) {
                    delayInput.value = min;
                } else {
                    delayInput.value = Math.round(value);
                }
                invalidatePreviewCache(); // ★ キャッシュ無効化
            });
            
            loopInput.addEventListener('blur', () => {
                const min = 0;
                let value = parseInt(loopInput.value, 10);
                if (isNaN(value) || value < min) {
                    loopInput.value = min;
                } else {
                    loopInput.value = Math.round(value);
                }
                invalidatePreviewCache(); // ★ キャッシュ無効化
            });

            outputWidthInput.addEventListener('blur', () => {
                if (outputWidthInput.value === '') return;
                const min = 1;
                let value = parseInt(outputWidthInput.value, 10);
                if (isNaN(value) || value < min) {
                    outputWidthInput.value = min;
                } else {
                    outputWidthInput.value = Math.round(value);
                }
                invalidatePreviewCache(); // ★ キャッシュ無効化
            });

            outputHeightInput.addEventListener('blur', () => {
                if (outputHeightInput.value === '') return;
                const min = 1;
                let value = parseInt(outputHeightInput.value, 10);
                if (isNaN(value) || value < min) {
                    outputHeightInput.value = min;
                } else {
                    outputHeightInput.value = Math.round(value);
                }
                invalidatePreviewCache(); // ★ キャッシュ無効化
            });

            // ★ 色深度セレクトボックスの変更イベント
            colorDepthSelect.addEventListener('change', invalidatePreviewCache);


            // --- ファイル処理 ---
            async function handleFiles(files) {
                const newFiles = Array.from(files).filter(file => {
                    return supportedTypes.includes(file.type);
                });
                
                if (newFiles.length === 0) return;

                const processingPromises = newFiles.map(file => processFile(file));
                
                try {
                    const processedFiles = await Promise.all(processingPromises.filter(p => p !== null));
                    mediaPool.push(...processedFiles);
                } catch (err) {
                    console.error("Error during file processing:", err);
                } finally {
                    renderMediaPool();
                }
            }

            async function processFile(file) {
                const id = crypto.randomUUID();
                try {
                    if (supportedTypes.includes(file.type)) {
                        const dataUrl = await blobToDataURL(file);
                        return {
                            id: id,
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            dataUrl: dataUrl,
                            originalFile: file, 
                        };
                    } else {
                        console.warn(`Skipping unsupported file: ${file.name}`);
                        return null;
                    }
                } catch (err) {
                    console.error(`Error processing file ${file.name}:`, err);
                    return null;
                }
            }

            function blobToDataURL(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsDataURL(blob);
                });
            }

            // --- UI描画 (ファイルリスト) ---

            function setDefaultDimensions(frameItem) {
                return new Promise((resolve, reject) => {
                    if (!frameItem) {
                        return reject(new Error("No frame item provided."));
                    }
                    
                    const img = new Image();
                    img.onload = () => {
                        if (!outputWidthInput.value) {
                            outputWidthInput.value = img.width;
                        }
                        if (!outputHeightInput.value) {
                            outputHeightInput.value = img.height;
                        }
                        resolve({ width: img.width, height: img.height });
                    };
                    img.onerror = (err) => {
                        console.error("Failed to load image to get dimensions:", frameItem.name);
                        reject(new Error(`Image load error: ${frameItem.name}`));
                    };
                    img.src = frameItem.dataUrl;
                });
            }

            function updateSequenceStats() {
                const frameCount = framesPool.length;
                const totalDelayMs = framesPool.reduce((sum, frame) => sum + (frame.delay || 0), 0);
                const totalSeconds = totalDelayMs / 1000.0;
                
                let avgFps = 0;
                if (totalSeconds > 0) {
                    avgFps = frameCount / totalSeconds;
                }

                if (seqFrameCountEl) seqFrameCountEl.textContent = frameCount;
                if (seqDurationEl) seqDurationEl.textContent = totalSeconds.toFixed(2);
                if (seqAvgFpsEl) seqAvgFpsEl.textContent = avgFps.toFixed(1);
            }


            function renderMediaPool() {
                const hasFiles = mediaPool.length > 0;

                clearPoolBtn.disabled = !hasFiles;
                sortAscBtn.disabled = !hasFiles;
                sortDescBtn.disabled = !hasFiles;
                sendToFramesBtn.disabled = !hasFiles;

                mediaList.innerHTML = '';
                
                if (!hasFiles) {
                    if (emptyPoolMessage) {
                        mediaList.appendChild(emptyPoolMessage);
                    }
                }

                mediaPool.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center bg-slate-700 p-3 rounded-lg shadow-md cursor-grab';
                    li.dataset.id = item.id;
                    li.draggable = true;

                    li.innerHTML = `
                        <div class="flex-grow overflow-hidden mr-4">
                            <p class="font-medium text-white truncate" title="${item.name}">${item.name}</p>
                        </div>
                        <button class="remove-btn text-red-500 hover:text-red-400 flex-shrink-0" title="削除">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                            </svg>
                        </button>
                    `;
                    mediaList.appendChild(li);
                });
            }

            // --- UI描画 (フレームシーケンス) ---

            function renderFramesList() {
                const hasFrames = framesPool.length > 0;
                
                convertBtnTop.disabled = !hasFrames;
                convertBtnBottom.disabled = !hasFrames;
                applyDelayAllBtn.disabled = !hasFrames;
                previewBtn.disabled = !hasFrames; // ★ プレビューボタンの disabled 状態も更新

                framesList.innerHTML = '';
                
                if (!hasFrames) {
                    if (emptyFramesMessage) {
                        framesList.appendChild(emptyFramesMessage);
                    }
                }

                framesPool.forEach((item, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex items-center bg-slate-700 p-3 rounded-lg shadow-md space-x-4 cursor-grab';
                    li.dataset.id = item.id;
                    li.draggable = true;

                    li.innerHTML = `
                        <span class="text-sm font-medium text-slate-400 w-6 text-center flex-shrink-0">${index + 1}</span>
                        <img src="${item.dataUrl}" alt="${item.name}" class="frame-preview rounded-md border border-slate-600 flex-shrink-0">
                        <div class="flex-grow overflow-hidden min-w-0">
                            <p class="font-medium text-white truncate" title="${item.name}">${item.name}</p>
                        </div>
                        <div class="flex-shrink-0">
                            <label for="frame-delay-${item.id}" class="block text-xs font-medium text-slate-300 mb-1 text-right">保持時間 (ms)</label>
                            <input type="number" id="frame-delay-${item.id}" value="${item.delay}" min="1" step="1" class="w-24 bg-slate-800 text-white border border-slate-600 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 frame-delay-input" data-id="${item.id}">
                        </div>
                        <button class="remove-frame-btn text-red-500 hover:text-red-400 flex-shrink-0" title="削除">
                            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
                            </svg>
                        </button>
                    `;
                    framesList.appendChild(li);
                });
                
                updateSequenceStats();
            }


            // --- イベントリスナー (リスト共通) ---

            mediaList.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-btn');
                if (removeBtn) {
                    const li = removeBtn.closest('li');
                    const id = li.dataset.id;
                    const index = mediaPool.findIndex(item => item.id === id);
                    if (index > -1) {
                        mediaPool.splice(index, 1);
                    }
                    renderMediaPool();
                }
            });

            framesListContainer.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-frame-btn');
                if (removeBtn) {
                    const li = removeBtn.closest('li');
                    const id = li.dataset.id;
                    const index = framesPool.findIndex(f => f.id === id);
                    if (index > -1) {
                        framesPool.splice(index, 1);
                    }
                    renderFramesList();
                    invalidatePreviewCache(); // ★ キャッシュ無効化

                    if (framesPool.length > 0) {
                        if (index === 0 && (!outputWidthInput.value || !outputHeightInput.value)) {
                            setDefaultDimensions(framesPool[0]).catch(console.error);
                        }
                    } else {
                        outputWidthInput.value = '';
                        outputHeightInput.value = '';
                    }
                }
            });
            
            framesListContainer.addEventListener('change', (e) => {
                if (e.target.classList.contains('frame-delay-input')) {
                    const id = e.target.dataset.id;
                    const item = framesPool.find(f => f.id === id);
                    
                    const min = 1;
                    let newDelay = parseInt(e.target.value, 10);

                    if (isNaN(newDelay) || newDelay < min) {
                        e.target.value = min;
                        newDelay = min;
                    } else {
                        newDelay = Math.round(newDelay);
                        e.target.value = newDelay;
                    }
                    
                    if (item) {
                        item.delay = newDelay;
                    }
                    
                    updateSequenceStats();
                    invalidatePreviewCache(); // ★ キャッシュ無効化
                }
            });

            // --- ドラッグ＆ドロップによる並び替え (両リスト対応) ---

            function handleDragStart(e, listType) {
                const li = e.target.closest('li');
                if (!li) return;
                draggingId = li.dataset.id;
                draggingList = listType;
                e.dataTransfer.setData('text/plain', draggingId);
                e.dataTransfer.effectAllowed = 'move';
                setTimeout(() => {
                    li.classList.add('dragging');
                }, 0);
            }

            function handleDragEnd(e) {
                if (draggingId) {
                    const li = document.querySelector(`li[data-id="${draggingId}"]`);
                    if (li) {
                        li.classList.remove('dragging');
                    }
                }
                document.querySelectorAll('.drag-over-indicator-before, .drag-over-indicator-after').forEach(el => {
                    el.classList.remove('drag-over-indicator-before', 'drag-over-indicator-after');
                });
                draggingId = null;
                dragOverId = null;
                draggingList = null;
            }

            function handleDragOver(e) {
                e.preventDefault();
                const targetLi = e.target.closest('li');
                
                if (!targetLi || targetLi.dataset.id === draggingId || !e.currentTarget.contains(targetLi)) {
                    if (dragOverId) {
                        const oldTarget = document.querySelector(`li[data-id="${dragOverId}"]`);
                        if(oldTarget) {
                            oldTarget.classList.remove('drag-over-indicator-before', 'drag-over-indicator-after');
                        }
                    }
                    dragOverId = null;
                    return;
                }
                
                const updateIndicator = (target) => {
                    const rect = target.getBoundingClientRect();
                    const isAfter = e.clientY > rect.top + rect.height / 2;
                    if (isAfter) {
                        target.classList.add('drag-over-indicator-after');
                        target.classList.remove('drag-over-indicator-before');
                    } else {
                        target.classList.add('drag-over-indicator-before');
                        target.classList.remove('drag-over-indicator-after');
                    }
                };

                if (targetLi.dataset.id !== dragOverId) {
                    document.querySelectorAll('.drag-over-indicator-before, .drag-over-indicator-after').forEach(el => {
                        el.classList.remove('drag-over-indicator-before', 'drag-over-indicator-after');
                    });
                    dragOverId = targetLi.dataset.id;
                    updateIndicator(targetLi);
                } else {
                    updateIndicator(targetLi);
                }
            }

            function handleDrop(e, listType) {
                e.preventDefault();
                
                if (!draggingId || draggingList !== listType) {
                    return;
                }

                const pool = (listType === 'media') ? mediaPool : framesPool;
                const draggingIndex = pool.findIndex(item => item.id === draggingId);
                if (draggingIndex === -1) return;

                const [draggedItem] = pool.splice(draggingIndex, 1);

                let targetIndex;
                const targetLi = e.target.closest('li');

                if (targetLi && targetLi.dataset.id !== draggingId) {
                    targetIndex = pool.findIndex(item => item.id === targetLi.dataset.id);
                    const rect = targetLi.getBoundingClientRect();
                    const isAfter = e.clientY > rect.top + rect.height / 2;
                    if (isAfter) targetIndex++;
                } else {
                    targetIndex = pool.length;
                }

                pool.splice(targetIndex, 0, draggedItem);

                if (listType === 'media') {
                    renderMediaPool();
                } else {
                    renderFramesList();
                    invalidatePreviewCache(); // ★ フレームリストの並び替えでキャッシュ無効化
                    
                    if (targetIndex === 0 || draggingIndex === 0) {
                        if (framesPool.length > 0 && (!outputWidthInput.value || !outputHeightInput.value)) {
                            setDefaultDimensions(framesPool[0]).catch(console.error);
                        }
                    }
                }
            }

            mediaList.addEventListener('dragstart', (e) => handleDragStart(e, 'media'));
            mediaList.addEventListener('dragend', handleDragEnd);
            mediaList.addEventListener('dragenter', (e) => e.preventDefault());
            mediaList.addEventListener('dragover', handleDragOver);
            mediaList.addEventListener('drop', (e) => handleDrop(e, 'media'));

            framesList.addEventListener('dragstart', (e) => handleDragStart(e, 'frames'));
            framesList.addEventListener('dragend', handleDragEnd);
            framesList.addEventListener('dragenter', (e) => e.preventDefault());
            framesList.addEventListener('dragover', handleDragOver);
            framesList.addEventListener('drop', (e) => handleDrop(e, 'frames'));


            // --- ▼▼▼ プレビューモーダル用関数 ▼▼▼ ---
            function openModal() {
                if (previewModal) previewModal.classList.remove('hidden');
            }
            function closeModal() {
                if (previewModal) previewModal.classList.add('hidden');
                // ★★★ キャッシュ保持のため、Blob URLの破棄処理を削除 ★★★
                // if (previewImage && previewImage.src.startsWith('blob:')) {
                //     URL.revokeObjectURL(previewImage.src);
                //     previewImage.src = "";
                // }
            }
            // プレビューボタン専用のローディング切り替え
            function togglePreviewLoading(show) {
                if (!previewBtn) return;
                
                previewBtn.disabled = show;
                const spinner = previewBtn.querySelector('svg');
                const text = previewBtn.querySelector('.btn-text');
                
                if (show) {
                    if (spinner) spinner.classList.remove('hidden');
                    if (text) text.textContent = '生成中...';
                } else {
                    if (spinner) spinner.classList.add('hidden');
                    if (text) text.textContent = 'プレビュー';
                    // 変換ボタンと違い、フレームがなければ disabled に戻す
                    previewBtn.disabled = framesPool.length === 0;
                }
            }

            // モーダル閉じるイベント
            closeModalBtn.addEventListener('click', closeModal);
            modalBgClose.addEventListener('click', closeModal);

            // --- ▲▲▲ プレビューモーダル用関数 ▲▲▲ ---


            // --- ▼▼▼ 共通APNG生成ロジック ▼▼▼ ---
            /**
             * 現在のフレームと設定に基づいてAPNGのArrayBufferを生成する
             * @param {function(string):void} progressCallback - 進捗を報告するコールバック
             * @returns {Promise<ArrayBuffer>} APNGデータのArrayBuffer
             */
            async function generateApngBuffer(progressCallback) {
                if (framesPool.length === 0) {
                    throw new Error("変換するフレームがありません。");
                }

                // --- 1. 設定値を取得 ---
                const loops = parseInt(loopInput.value, 10) || 0;
                let outputWidth = outputWidthInput.value ? parseInt(outputWidthInput.value, 10) : null;
                let outputHeight = outputHeightInput.value ? parseInt(outputHeightInput.value, 10) : null;
                
                const selectedDepth = parseInt(colorDepthSelect.value, 10);
                const enableQuantization = selectedDepth > 0;
                let quantizeColorCount = 0;
                if (enableQuantization) {
                    quantizeColorCount = Math.pow(2, selectedDepth);
                }

                // --- 2. フレームデータを準備 (デコード＆リサイズ) ---
                const frameImages = []; // デコードされたRGBA8ピクセルデータ (ArrayBuffer)
                const frameDelays = []; // 遅延 (ms)
                
                let resizeCanvas = null;
                let resizeCtx = null;

                for (let i = 0; i < framesPool.length; i++) {
                    const frame = framesPool[i];
                    
                    progressCallback(`フレーム ${i + 1} / ${framesPool.length} を処理中...`);
                    
                    const fileBuffer = await frame.originalFile.arrayBuffer();
                    const decodedPng = UPNG.decode(fileBuffer);
                    
                    if (i === 0) {
                        if (outputWidth === null) outputWidth = decodedPng.width;
                        if (outputHeight === null) outputHeight = decodedPng.height;

                        resizeCanvas = document.createElement('canvas');
                        resizeCtx = resizeCanvas.getContext('2d', { willReadFrequently: true });
                        resizeCanvas.width = outputWidth;
                        resizeCanvas.height = outputHeight;
                    }
                    
                    const rgba8Buffer = UPNG.toRGBA8(decodedPng)[0];
                    
                    if (decodedPng.width === outputWidth && decodedPng.height === outputHeight) {
                        frameImages.push(rgba8Buffer);
                    } else {
                        // リサイズ処理
                        progressCallback(`フレーム ${i + 1} / ${framesPool.length} をリサイズ中...`);
                        try {
                            const originalImageData = new ImageData(
                                new Uint8ClampedArray(rgba8Buffer),
                                decodedPng.width,
                                decodedPng.height
                            );
                            const imageBitmap = await createImageBitmap(originalImageData);
                            resizeCtx.clearRect(0, 0, outputWidth, outputHeight); 
                            resizeCtx.drawImage(imageBitmap, 0, 0, outputWidth, outputHeight);
                            imageBitmap.close();
                            const resizedImageData = resizeCtx.getImageData(0, 0, outputWidth, outputHeight);
                            frameImages.push(resizedImageData.data.buffer.slice(0));
                        } catch (resizeError) {
                            console.error(`フレーム ${i + 1} (${frame.name}) のリサイズに失敗:`, resizeError);
                            throw new Error(`フレーム ${i + 1} (${frame.name}) のリサイズに失敗しました。`);
                        }
                    }
                    frameDelays.push(frame.delay);
                }

                // --- 2b. (オプション) 色の量子化 ---
                let cnum = 0; 
                if (enableQuantization) {
                    progressCallback(`色を圧縮中 (${quantizeColorCount}色)...`);
                    try {
                        UPNG.quantize(frameImages, quantizeColorCount); 
                        cnum = quantizeColorCount;
                    } catch (quantError) {
                        console.error("量子化中にエラー:", quantError);
                        throw new Error(`色の圧縮中にエラーが発生しました: ${quantError.message}`);
                    }
                }

                progressCallback("APNGファイルを生成中...");

                // --- 3. UPNG.jsでエンコード ---
                const apngBuffer = UPNG.encode(
                    frameImages,      
                    outputWidth,      
                    outputHeight,     
                    cnum,             
                    frameDelays,      
                    loops             
                );
                
                return apngBuffer; // ArrayBufferを返す
            }
            // --- ▲▲▲ 共通APNG生成ロジック ▲▲▲ ---


            // --- 変換処理 (ダウンロード) ---
            async function handleConversion() {
                toggleLoading(true, "準備中...");
                
                try {
                    // 共通関数を呼び出し、進捗を toggleLoading に渡す
                    const apngBuffer = await generateApngBuffer((progressText) => {
                        toggleLoading(true, progressText);
                    });

                    toggleLoading(true, "ダウンロードを準備中...");

                    // --- 4. ダウンロード処理 ---
                    const blob = new Blob([apngBuffer], { type: 'image/png' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `animation.png`; 
                    document.body.appendChild(a);
                    a.click();
                    
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                } catch (error) {
                    console.error("APNG変換中にエラーが発生しました:", error);
                    alert("APNG変換エラー:\n" + error.message); 
                } finally {
                    toggleLoading(false);
                }
            }
            
            // --- プレビュー処理 ---
            async function handlePreview() {
                if (framesPool.length === 0) {
                    console.log("プレビューするフレームがありません。");
                    return;
                }

                // ▼▼▼ キャッシュ確認ロジック ▼▼▼
                const currentHash = getCurrentSettingsHash();
                if (currentHash === lastPreviewSettingsHash && lastPreviewBlobUrl) {
                    // console.log("Using cached preview."); // デバッグ用
                    previewImage.src = lastPreviewBlobUrl;
                    openModal();
                    return; // 再生成せずに終了
                }
                // ▲▲▲ キャッシュ確認ロジック ▲▲▲
                
                // プレビューボタンをローディング状態に
                togglePreviewLoading(true);

                try {
                    // console.log("Generating new preview..."); // デバッグ用
                    // 共通関数を呼び出し (プレビュー時は簡易的な進捗)
                    const apngBuffer = await generateApngBuffer((progressText) => {
                         // プレビューボタンのテキストで進捗を表示 (オプション)
                         const textEl = previewBtn.querySelector('.btn-text');
                         if (textEl) textEl.textContent = '生成中...';
                    }); 
                    
                    const blob = new Blob([apngBuffer], { type: 'image/png' });
                    
                    // ★ 既存のキャッシュURLがあれば破棄
                    if (lastPreviewBlobUrl) {
                        URL.revokeObjectURL(lastPreviewBlobUrl);
                        // console.log("Old preview cache (Blob) revoked."); // デバッグ用
                    }
                    
                    const url = URL.createObjectURL(blob);
                    previewImage.src = url;

                    // ▼▼▼ 新しいキャッシュを保存 ▼▼▼
                    lastPreviewBlobUrl = url;
                    lastPreviewSettingsHash = currentHash;
                    // ▲▲▲ 新しいキャッシュを保存 ▲▲▲
                    
                    openModal();

                } catch (error) {
                    console.error("APNGプレビュー生成中にエラーが発生しました:", error);
                    alert("APNGプレビュー生成エラー:\n" + error.message); 
                    invalidatePreviewCache(); // エラー時はキャッシュを破棄
                } finally {
                    // プレビューボタンのローディング解除
                    togglePreviewLoading(false);
                }
            }


            /**
             * ローディングUI（ボタンとオーバーレイ）の表示/非表示を切り替える
             */
            function toggleLoading(show, progressText = "") {
                const buttons = [convertBtnTop, convertBtnBottom];
                
                if (show) {
                    if (loadingOverlay) loadingOverlay.classList.remove('hidden');
                    if (loadingProgress) loadingProgress.textContent = progressText;
                    
                    // 変換中はプレビューボタンも無効化する
                    if (previewBtn) previewBtn.disabled = true;

                    buttons.forEach(btn => {
                        btn.disabled = true;
                        const spinner = btn.querySelector('svg');
                        const text = btn.querySelector('.btn-text');
                        if (spinner) spinner.classList.remove('hidden');
                        if (text) text.textContent = '変換中...';
                    });
                } else {
                    if (loadingOverlay) loadingOverlay.classList.add('hidden');
                    if (loadingProgress) loadingProgress.textContent = "";

                    // 変換完了後、フレームがあればプレビューボタンを有効化
                    if (previewBtn) previewBtn.disabled = framesPool.length === 0;

                    buttons.forEach(btn => {
                        btn.disabled = framesPool.length === 0;
                        const spinner = btn.querySelector('svg');
                        const text = btn.querySelector('.btn-text');
                        if (spinner) spinner.classList.add('hidden');
                        if (text) text.textContent = 'APNGに変換';
                    });
                }
            }

            // ★ 各ボタンにイベントリスナーを登録 ★
            convertBtnTop.addEventListener('click', handleConversion);
            convertBtnBottom.addEventListener('click', handleConversion);
            previewBtn.addEventListener('click', handlePreview); // ★ プレビューボタン

            // --- 初期描画 ---
            renderMediaPool();
            renderFramesList();

        });
    </script>
</body>
</html>